<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>spotynif embed</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="favicon.svg" />
  <meta name="description" content="enhanced spotify card by spotynif">
  <style>
    html, body, #embedroot {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      background: transparent;
      font-family: 'NotoSansMono', 'Noto Sans Mono', monospace;
    }
    
    #embedroot {
      width: 100%;
      max-width: 420px;
      position: relative;
    }

    :root {
      --song-font: inherit;
      --artist-font: inherit;
      --username-font: inherit;
      --customtext-font: inherit;
    }

    .song {
      font-family: var(--song-font) !important;
    }

    .artist {
      font-family: var(--artist-font) !important;
    }

    .username {
      font-family: var(--username-font) !important;
    }

    .customtext {
      font-family: var(--customtext-font) !important;
    }
  </style>
</head>
<body>
  <div id="embedroot"></div>

  <script>
    (function() {
      const urlparams = new URLSearchParams(location.search);
      const discordid = urlparams.get('id') || urlparams.get('uid') || '';
      const showartist = urlparams.get('showArtist') !== 'false';
      const showprogress = urlparams.get('showProgress') !== 'false';
      const showalbum = urlparams.get('showAlbum') !== 'false';
      const showusername = urlparams.get('showUsername') !== 'false';
      const showduration = urlparams.get('showDuration') !== 'false';
      const showstatus = urlparams.get('showStatus') === 'true';
      const cardtheme = urlparams.get('theme') === 'light' ? 'light' : 'dark';
      const customtxt = urlparams.get('custom') || '';
      const customsongcolor = urlparams.get('songColor') || '';
      const customartistcolor = urlparams.get('artistColor') || '';
      const customusernamecolor = urlparams.get('usernameColor') || '';
      const customtextcolor = urlparams.get('customTextColor') || '';
      const customprogressbgcolor = urlparams.get('progressBgColor') || '';
      const customprogressfillcolor = urlparams.get('progressFillColor') || '';
      const songeffect = urlparams.get('songEffect') || 'none';
      const artisteffect = urlparams.get('artistEffect') || 'none';
      const usernameeffect = urlparams.get('usernameEffect') || 'none';
      const customtexteffect = urlparams.get('customTextEffect') || 'none';
      const cardentrance = urlparams.get('cardEntrance') || 'none';
      const cardhover = urlparams.get('cardHover') || 'none';
      const albumarteffect = urlparams.get('albumArtEffect') || 'none';
      const progressstyle = urlparams.get('progressStyle') || 'default';
      const progressheight = urlparams.get('progressHeight') || '6';
      const progressradius = urlparams.get('progressRadius') || '3';
      const songfont = urlparams.get('songFont') || 'default';
      const artistfont = urlparams.get('artistFont') || 'default';
      const usernamefont = urlparams.get('usernameFont') || 'default';
      const customtextfont = urlparams.get('customTextFont') || 'default';

      if (cardtheme === 'light') {
        document.body.classList.add('cardlight');
      }

      const documentroot = document.documentElement;
      if (customsongcolor) documentroot.style.setProperty('--song-color', customsongcolor);
      if (customartistcolor) documentroot.style.setProperty('--artist-color', customartistcolor);
      if (customusernamecolor) documentroot.style.setProperty('--username-color', customusernamecolor);
      if (customtextcolor) documentroot.style.setProperty('--customtext-color', customtextcolor);
      if (customprogressbgcolor) documentroot.style.setProperty('--progress-bg-color', customprogressbgcolor);
      if (customprogressfillcolor) documentroot.style.setProperty('--progress-fill-color', customprogressfillcolor);
      documentroot.style.setProperty('--progress-height', progressheight + 'px');
      documentroot.style.setProperty('--progress-radius', progressradius + 'px');

      function setfontfamily(fontvalue, elementtype) {
        let fontfamily = '';
        
        switch(fontvalue) {
          case 'default':
            fontfamily = 'inherit';
            break;
          case 'inter':
            fontfamily = '"Inter", sans-serif';
            break;
          case 'merriweather':
            fontfamily = '"Merriweather", serif';
            break;
          case 'firacode':
            fontfamily = '"Fira Code", monospace';
            break;
          case 'dancingscript':
            fontfamily = '"Dancing Script", cursive';
            break;
          case 'oswald':
            fontfamily = '"Oswald", sans-serif';
            break;
          case 'pacifico':
            fontfamily = '"Pacifico", cursive';
            break;
          case 'inconsolata':
            fontfamily = '"Inconsolata", monospace';
            break;
          case 'lobster':
            fontfamily = '"Lobster", cursive';
            break;
          default:
            fontfamily = 'inherit';
        }
        
        documentroot.style.setProperty(`--${elementtype}-font`, fontfamily);
      }

      function loadgooglefont(fontname) {
        return new Promise((resolve) => {
          const fontmap = {
            inter: 'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap',
            merriweather: 'https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700;900&display=swap',
            firacode: 'https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap',
            dancingscript: 'https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&display=swap',
            oswald: 'https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&display=swap',
            pacifico: 'https://fonts.googleapis.com/css2?family=Pacifico&display=swap',
            inconsolata: 'https://fonts.googleapis.com/css2?family=Inconsolata:wght@300;400;500;700&display=swap',
            lobster: 'https://fonts.googleapis.com/css2?family=Lobster&display=swap'
          };
          
          if (fontmap[fontname] && !document.querySelector(`link[href="${fontmap[fontname]}"]`)) {
            const link = document.createElement('link');
            link.href = fontmap[fontname];
            link.rel = 'stylesheet';
            link.onload = () => resolve();
            link.onerror = () => resolve();
            document.head.appendChild(link);
          } else {
            resolve();
          }
        });
      }

      async function initfonts() {
        const fonts = [
          { value: songfont, type: 'song' },
          { value: artistfont, type: 'artist' },
          { value: usernamefont, type: 'username' },
          { value: customtextfont, type: 'customtext' }
        ];

        const googlefonts = fonts.filter(f => ['inter', 'merriweather', 'firacode', 'dancingscript', 'oswald', 'pacifico', 'inconsolata', 'lobster'].includes(f.value));
        
        if (googlefonts.length > 0) {
          await Promise.all(googlefonts.map(f => loadgooglefont(f.value)));
        }

        fonts.forEach(font => {
          setfontfamily(font.value, font.type);
        });
      }

      const rootcontainer = document.getElementById('embedroot');

      if (!discordid) {
        rootcontainer.innerHTML = '<div class="player"><div class="meta"><div class="song">missing id</div><div class="artist">please provide a discord user id</div></div></div>';
        return;
      }

      const formatduration = ms => {
        if (!ms) return '0:00';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingsecs = String(seconds % 60).padStart(2, '0');
        return `${minutes}:${remainingsecs}`;
      };

      const applyeffect = (element, effect) => {
        if (!element || effect === 'none') return;
        element.classList.add(effect);
      };

      let presencedata = null;
      let frameanimation = null;
      let websocket = null;
      let reconnecttimeout = null;
      
      function getprogress(spotifydata) {
        if (!spotifydata || !spotifydata.timestamps) return null;
        const starttime = spotifydata.timestamps.start;
        const endtime = spotifydata.timestamps.end;
        if (!starttime || !endtime) return null;
        const totaldur = endtime - starttime;
        const currentelapsed = Date.now() - starttime;
        const progresspct = Math.max(0, Math.min(1, currentelapsed / totaldur));
        
        return { 
          elapsed: currentelapsed, 
          duration: totaldur, 
          percent: progresspct 
        };
      }

      let playercard = null;
      let albumart = null;
      let tracktitle = null;
      let trackartist = null;
      let username = null;
      let custommsg = null;
      let statusdot = null;
      let currenttime = null;
      let totaltime = null;
      let progressbar = null;
      let progressfill = null;
      let lastspotifydata = null;

      function createplayer() {
        if (playercard) return;
        
        rootcontainer.innerHTML = '';
        playercard = document.createElement('div');
        playercard.className = 'player';
        
        if (cardentrance !== 'none') {
          playercard.classList.add(cardentrance);
        }
        if (cardhover !== 'none') {
          playercard.classList.add('hover' + cardhover);
        }
        
        if (showalbum) {
          albumart = document.createElement('img');
          albumart.className = 'art';
          albumart.style.display = 'none';
          albumart.onerror = () => albumart.style.display = 'none';
          if (albumarteffect !== 'none') {
            albumart.classList.add('art' + albumarteffect);
          }
          playercard.appendChild(albumart);
        }
        
        const trackinfo = document.createElement('div');
        trackinfo.className = 'meta';
        
        if (showstatus) {
          statusdot = document.createElement('div');
          statusdot.className = 'statusindicator statusoffline';
          trackinfo.appendChild(statusdot);
        }
        
        tracktitle = document.createElement('div');
        tracktitle.className = 'song';
        tracktitle.textContent = '— not listening';
        applyeffect(tracktitle, songeffect);
        trackinfo.appendChild(tracktitle);
        
        if (showartist) {
          trackartist = document.createElement('div');
          trackartist.className = 'artist';
          trackartist.style.display = 'none';
          applyeffect(trackartist, artisteffect);
          trackinfo.appendChild(trackartist);
        }
        
        if (showusername) {
          username = document.createElement('div');
          username.className = 'username';
          username.style.display = 'none';
          applyeffect(username, usernameeffect);
          trackinfo.appendChild(username);
        }
        
        if (customtxt) {
          custommsg = document.createElement('div');
          custommsg.className = 'customtext';
          custommsg.textContent = customtxt;
          applyeffect(custommsg, customtexteffect);
          trackinfo.appendChild(custommsg);
        }
        
        if (showprogress && showduration) {
          const timedisplay = document.createElement('div');
          timedisplay.className = 'timerow';
          currenttime = document.createElement('span');
          totaltime = document.createElement('span');
          currenttime.textContent = '--:--';
          totaltime.textContent = '--:--';
          timedisplay.appendChild(currenttime);
          timedisplay.appendChild(totaltime);
          
          progressbar = document.createElement('div');
          progressbar.className = 'progressbar';
          if (progressstyle !== 'default') {
            progressbar.classList.add('progress' + progressstyle);
          }
          progressfill = document.createElement('div');
          progressfill.className = 'progressfill';
          progressbar.appendChild(progressfill);
          
          trackinfo.appendChild(timedisplay);
          trackinfo.appendChild(progressbar);
        } else if (showprogress) {
          progressbar = document.createElement('div');
          progressbar.className = 'progressbar';
          if (progressstyle !== 'default') {
            progressbar.classList.add('progress' + progressstyle);
          }
          progressfill = document.createElement('div');
          progressfill.className = 'progressfill';
          progressbar.appendChild(progressfill);
          trackinfo.appendChild(progressbar);
        }

        playercard.appendChild(trackinfo);
        rootcontainer.appendChild(playercard);
      }

      function updateplayer() {
        if (!playercard) createplayer();
        if (!presencedata) return;

        const spotifyinfo = presencedata.spotify ?? null;
        const discorduser = presencedata.discord_user?.username ?? null;
        const discordstatus = presencedata.discord_status || 'offline';
        
        if (tracktitle) {
          const songtitle = spotifyinfo?.song ?? '— not listening';
          tracktitle.textContent = songtitle;
        }
        
        if (trackartist && showartist) {
          if (spotifyinfo?.artist) {
            const artistname = spotifyinfo.artist;
            trackartist.textContent = artistname;
            trackartist.style.display = 'block';
          } else {
            trackartist.style.display = 'none';
          }
        }
        
        if (albumart && showalbum) {
          if (spotifyinfo?.album_art_url) {
            albumart.src = spotifyinfo.album_art_url;
            albumart.style.display = 'block';
          } else {
            albumart.style.display = 'none';
          }
        }
        
        if (username && showusername) {
          if (discorduser) {
            const displayname = `@${discorduser}`;
            username.textContent = displayname;
            username.style.display = 'block';
          } else {
            username.style.display = 'none';
          }
        }
        
        if (statusdot && showstatus) {
          statusdot.className = `statusindicator status${discordstatus}`;
        }
        
        lastspotifydata = spotifyinfo;
      }

      function updateprogress() {
        if (!showprogress || !lastspotifydata || !progressfill) {
          if (frameanimation) frameanimation = requestAnimationFrame(updateprogress);
          return;
        }
        
        const progress = getprogress(lastspotifydata);
        if (progress && lastspotifydata.timestamps) {
          if (currenttime) currenttime.textContent = formatduration(progress.elapsed);
          if (totaltime) totaltime.textContent = formatduration(progress.duration);
          progressfill.style.transform = `scaleX(${progress.percent})`;
        } else {
          if (currenttime) currenttime.textContent = '--:--';
          if (totaltime) totaltime.textContent = '--:--';
          progressfill.style.transform = 'scaleX(0)';
        }
        frameanimation = requestAnimationFrame(updateprogress);
      }

      function drawplayer() {
        updateplayer();
        if (frameanimation) cancelAnimationFrame(frameanimation);
        frameanimation = requestAnimationFrame(updateprogress);
      }

      function connectwebsocket() {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          websocket.close();
        }
        
        websocket = new WebSocket('wss://api.lanyard.rest/socket');
        
        websocket.onopen = () => {
          const initpayload = {
            op: 2,
            d: {
              subscribe_to_id: discordid
            }
          };
          websocket.send(JSON.stringify(initpayload));
        };
        
        websocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handlewebsocketmessage(data);
          } catch (error) {
            console.warn('websocket message error:', error);
          }
        };
        
        websocket.onclose = () => {
          schedulewebsocketreconnect();
        };
        
        websocket.onerror = (error) => {
          console.warn('websocket error:', error);
        };
      }

      function handlewebsocketmessage(data) {
        switch (data.op) {
          case 0:
            if (data.d) {
              presencedata = data.d;
              drawplayer();
            }
            break;
          case 1:
            if (websocket && websocket.readyState === WebSocket.OPEN) {
              websocket.send(JSON.stringify({ op: 3 }));
            }
            break;
        }
      }

      function schedulewebsocketreconnect() {
        if (reconnecttimeout) {
          clearTimeout(reconnecttimeout);
        }
        reconnecttimeout = setTimeout(() => {
          connectwebsocket();
        }, 3000);
      }

      function closewebsocket() {
        if (websocket) {
          websocket.close();
          websocket = null;
        }
        if (reconnecttimeout) {
          clearTimeout(reconnecttimeout);
          reconnecttimeout = null;
        }
      }

      async function fetchdatafallback() {
        try {
          const response = await fetch(`https://api.lanyard.rest/v1/users/${discordid}`);
          const jsondata = await response.json();
          if (jsondata && jsondata.success && jsondata.data) {
            presencedata = jsondata.data;
            drawplayer();
          } else {
            if (!playercard) {
              rootcontainer.innerHTML = '<div class="player"><div class="meta"><div class="song">user not found</div><div class="artist">check discord id</div></div></div>';
            }
          }
        } catch (error) {
          console.warn('fallback fetch failed:', error);
          if (!playercard) {
            rootcontainer.innerHTML = '<div class="player"><div class="meta"><div class="song">connection error</div><div class="artist">retrying...</div></div></div>';
          }
        }
      }

      initfonts().then(() => {
        connectwebsocket();
      });

      window.addEventListener('beforeunload', () => {
        closewebsocket();
        if (frameanimation) cancelAnimationFrame(frameanimation);
      });

    })();
  </script>
</body>
</html>
